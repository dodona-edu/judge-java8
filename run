#!/bin/bash

debug() { echo -n "$@" " - " >&2; date >&2; }
debug start

set -o pipefail -e

# Temp files
config="$(mktemp)"      # configuration
result="$(mktemp)"      # result json
compilation="$(mktemp)" # output of compilation
execution="$(mktemp)"   # output of execution
mkdir "/tmp/build"      # compilation directory

trap "rm -rf '$config' '$result' '$compilation' '$execution' '/tmp/build'" EXIT

# Saving the configuration from stdin
cat > "$config"

# Directories containing the test files and the judge repository
resources="$(jshon -e 'resources' -u < "$config")"
judge="$(jshon -e 'judge' -u < "$config")"
workdir="$(jshon -e 'workdir' -u < "$config")"
filename="$(jshon -e 'filename' -u < "$config")"

# time and memory limit with margins
time_limit="$(jshon -e 'time_limit' -u < "$config")"
time_limit="$(( time_limit - 10 ))"

memory_limit="$(jshon -e 'memory_limit' -u < "$config")"
memory_limit="$(( memory_limit * 9 / 10000 ))"

############################## [ Helper functions ] ############################
# Import json helper functions.
source $judge/dodona-json

compilation_error_count() {
    echo "$1" | sed -n 's/^\([0-9]\+\) errors\?$/\1/p'
}

compilation_warning_count() {
    echo "$1" | sed -n 's/^\([0-9]\+\) warnings\?$/\1/p'
}

explain_compilation_error() {
    if echo "$1" | head -1 | grep -q "should be declared in a file named"; then
        # Wrong class name.
        expected_class_name="${filename%.java}"
        echo "De naam van je klasse hoort \"$expected_class_name\" te zijn."
    elif echo "$1" | grep -q "cannot find symbol"; then
        # Cannot find symbol - forgotten import.
        class_name=$(echo "$1" | grep -o "symbol:\s*class \S\+" | sed "s/.*class \(\S\+\)\\\n/\1/" || true)
        [[ -z "$class_name" ]] || echo "Je probeert een onbekende klasse \`$class_name\` te gebruiken. Mogelijks ben je de noodzakelijke \`import\` vergeten."
    elif echo "$1" | grep -q "assign a value to final variable"; then
        # Assignment to final variable.
        variable_name=$(echo "$1" | grep -o "final variable \S\+" | sed "s/final variable //" | sed "s/\\\n//")
        echo "Variabelen die als \`final\` zijn gedeclareerd, kunnen niet meer worden aangepast eens ze een waarde hebben. Verwijder het \`final\` keyword bij de variabele \"$variable_name\" om dit op te lossen."
    else
        # Empty explanation.
        echo ""
    fi
}

explain_compilation_warning() {
    if echo "$1" | grep -q "found raw type"; then
        echo "Het is aangeraden een type mee te geven aan generieke klassen."
    fi
}

parse_compilation_error_staff() {
    # arg1: 1 compiler log

    dodona_start_context

    # Start the case.
    dodona_start_testcase_markdown_message "Compilatiefout"

    # Append the compilation log, only visible for staff.
    dodona_append_code_message_staff "$1"

    dodona_close_failed_testcase
    dodona_close_failed_context
}

parse_compilation_error_student() {
    # arg1: 1 compiler log

    dodona_start_context

    # Determine the kind of compilation message.
    log_kind=$(echo "$1" | grep -o "^$filename:[0-9]\+: warning:" | grep -o "warning" || echo 'error')

    # Try to explain the compilation message.
    if [[ "$log_kind" == 'error' ]]; then
        explanation=$(explain_compilation_error "$1")
    else
        explanation=$(explain_compilation_warning "$1")
    fi

    # Start the case, add the explanation message if it exists.
    [[ "$log_kind" == 'error' ]] && testcase_msg="Compilatiefout" || testcase_msg="Compilatiewaarschuwing"
    [[ -z "$explanation" ]] || testcase_msg+=": $explanation"
    dodona_start_testcase_markdown_message "$testcase_msg"

    # Append the compilation output.
    dodona_append_code_message "$1"

    # Get the code annotation information.
    annotation_column=$(echo "$1" | grep -o "\s*\^" | wc -c)
    annotation_column=$((annotation_column - 2))
    annotation_row=$(echo "$1" | sed "s/^$filename:\([0-9]\+\):.*/\1/g")
    annotation_row=$((annotation_row - 1))

    if [[ -z "$explanation" ]]; then
        # Insert the first line of the compilation log.
        annotation_text=$(echo -e "$1" | sed "s/.*: error://" | sed "s/.*: warning://" | head -n 1)
    else
        # Strip the ` from markdown explanations.
        annotation_text=$(echo "$explanation" | tr -d '\`')
    fi

    # Annotate the code accordingly.
    dodona_annotate_code "$log_kind" "$annotation_row" "$annotation_column" "$annotation_text"

    dodona_close_failed_testcase
    dodona_close_failed_context
}

parse_compilation_errors() {
    # arg1: permission
    # arg2: raw compilation output

    # Loop over the compile log and process each message individually.
    compile_err=""
    while IFS="\n" read -r line; do
        new_case=$(echo "$line" | egrep -c "^$filename:[0-9]+:" || true)

        if [[ "$new_case" == "0" || -z "$compile_err" ]]; then
            compile_err+="$line\n"
            continue
        fi

        if [[ "$1" == 'student' ]]; then
            parse_compilation_error_student "$compile_err" </dev/zero
        else
            parse_compilation_error_staff "$compile_err" </dev/zero
        fi

        compile_err="$line\n"
    done <<< "$2"

    # Last error/warning will end with "x errors/y warnings; remove this part."
    compile_err=$(echo "$compile_err" | sed "s/[0-9]\+ warnings\?//g")
    compile_err=$(echo "$compile_err" | sed "s/[0-9]\+ errors\?//g")

    # Process the last error/warning.
    if [[ "$1" == 'student' ]]; then
        parse_compilation_error_student "$compile_err" </dev/zero
    else
        parse_compilation_error_staff "$compile_err" </dev/zero
    fi
}

compilation_error_in_submission() {
    compile_log=$(cat $1)

    # Parse the amount of compilation errors and warnings.
    compile_err_count=$(compilation_error_count "$compile_log")
    compile_warn_count=$(compilation_warning_count "$compile_log")
    compile_errwarn_sum="$((compile_err_count + compile_warn_count))"

    # Get the correct noun.
    [[ "$compile_err_count" == "1" ]] && compile_err_noun="fout" || compile_err_noun="fouten"
    [[ "$compile_warn_count" == "1" ]] && compile_warn_noun="waarschuwing" || compile_warn_noun="waarschuwingen"

    # Build the compilation message.
    compile_message=""
    [[ "$compile_err_count" == "" ]] || compile_message="$compile_err_count $compile_err_noun"
    [[ "$compile_err_count" != "" && "$compile_warn_count" != "" ]] && compile_message+=" en "
    [[ "$compile_warn_count" == "" ]] || compile_message+="$compile_warn_count $compile_warn_noun"

    dodona_start_judgement
    dodona_start_tab "Compiler"
    dodona_append_html_message "<div class=\"callout callout-info\">Je code kon niet worden gecompileerd en bijgevolg niet worden uitgevoerd. De compiler rapporteerde $compile_message.</div>"

    parse_compilation_errors 'student' "$compile_log"

    dodona_close_tab $compile_errwarn_sum
    dodona_close_judgement_compilation_error "$compile_err_count $compile_err_noun"
}

compilation_error_in_tests() {
    compile_log=$(cat $1)

    dodona_start_judgement
    dodona_start_tab "Compiler"
    dodona_append_html_message "<div class=\"callout callout-info\">Er ging iets mis tijdens het compileren van de testen voor deze oefening. Contacteer je lesgever.</div>"

    parse_compilation_errors 'staff' "$compile_log"

    dodona_close_tab
    dodona_close_judgement_compilation_error "in de testen"
}


################################# [ Start run ] ################################

# Record time
start_time="$(date +"%s")"

debug after init

# Compiling judge into "build" and getting a jar in the workdir
find "$judge/src" -name '*.java' \
    | xargs javac -classpath "$judge/lib/*:/tmp/build" -d /tmp/build -sourcepath "$judge/src"
jar -cf "judge.jar" -C /tmp/build .
testlibs="$(find "$judge/lib" "$resources" -name '*.jar' | xargs echo | tr ' ' ':')"
worklibs="$(find "$workdir" -name '*.jar' | xargs echo | tr ' ' ':')"

debug compiled judge

# Compiling the workdir given code
if ! find . -name '*.java' | xargs --no-run-if-empty javac -cp ".:${worklibs}:${testlibs}" -d . -sourcepath . > "$compilation" 2>&1; then
    compilation_error_in_submission <(sed 's_.*/\([^/]*.java\)_\1_' "$compilation")
    exit 0
fi

debug compiled workdir

# Create the Input.java class, containing the submitted code
cat "$(jshon -e 'source' -u < "$config")" > "$filename"

# Compiling the user code
if ! javac -cp ".:${worklibs}" -Xlint:all "$filename" > "$compilation" 2>&1; then
    compilation_error_in_submission "$compilation"
    exit 0
fi

debug compiled user code

# Compiling the tests
if ! find "$resources" -name '*.java' | xargs javac -cp ".:${resources}:${worklibs}:${testlibs}:judge.jar" -d . -sourcepath "$resources" > "$compilation" 2>&1; then
    compilation_error_in_submission <(sed 's_.*/\([^/]*.java\)_\1_' "$compilation")
    exit 0
fi

debug compiled tests

# Record time
compiled_time="$(date +"%s")"
compilation_time="$((compiled_time - start_time))"

# Running the tests
timeout --preserve-status "$((time_limit - compilation_time))" java -Xmx"${memory_limit}k" -cp ".:${worklibs}:${testlibs}:judge.jar" dodona.junit.JUnitJSON

debug finished
